package com.example.mooddetection

import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material.AlertDialog
import androidx.compose.material.Button
import androidx.compose.material.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.dp
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlin.random.Random

class DailyGame : ComponentActivity(), SensorEventListener {
    private lateinit var sensorManager: SensorManager
    private var accelerometerSensor: Sensor? = null
    private var isPlatformsGenerated by mutableStateOf(false)
    private val characterSize = 50.dp
    private val platformSize = 100.dp

    private var screenWidth by mutableStateOf(0.dp)
    private var screenHeight by mutableStateOf(0.dp)

    private val platforms = mutableStateListOf<Platform>()

    private val characterPosition = mutableStateOf(Offset(0f, 0f))

    private val tiltSensitivity = 0.5f
    private var tiltOffset = 0f

    private var characterSizePx = 0f
    private var platformSizePx = 0f
    private var screenWidthPx = 0f
    private var screenHeightPx = 0f

    private var isJumping by mutableStateOf(false)

    private var dialogVisible by mutableStateOf(false)

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager
        accelerometerSensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)

        setContent {
            DailyGame()
        }
    }

    override fun onResume() {
        super.onResume()
        accelerometerSensor?.let {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_GAME)
        }
    }

    override fun onPause() {
        super.onPause()
        sensorManager.unregisterListener(this)
    }

    override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {
        // Not used
    }

    private fun launchFallAnimation() {
        val fallSpeed = 20f
        val fallThreshold = screenHeightPx + characterSizePx

        lifecycleScope.launch {
            var yPos = characterPosition.value.y

            while (!checkPlatformCollision() && yPos < fallThreshold) {
                yPos += fallSpeed
                characterPosition.value = Offset(characterPosition.value.x, yPos.coerceAtMost(fallThreshold))
                delay(50)
            }

            // If character is off the screen, reset to the first platform
            if(yPos >= screenHeightPx) {
                characterPosition.value = Offset(platforms[0].position.x, platforms[0].position.y - characterSizePx)
            }
        }
    }

    override fun onSensorChanged(event: SensorEvent) {
        if (event.sensor.type == Sensor.TYPE_ACCELEROMETER) {
            val x = event.values[0]
            tiltOffset = x * tiltSensitivity
            if (!isJumping && !checkPlatformCollision()) {
                launchFallAnimation()
            } else {
                checkPlatformCollision()
            }
        }
    }

    @Composable
    fun DailyGame() {
        val configuration = LocalConfiguration.current
        val density = LocalDensity.current

        screenWidth = configuration.screenWidthDp.dp
        screenHeight = configuration.screenHeightDp.dp
        characterSizePx = with(density) { characterSize.toPx() }
        platformSizePx = with(density) { platformSize.toPx() }
        screenWidthPx = with(density) { screenWidth.toPx() }
        screenHeightPx = with(density) { screenHeight.toPx() }

        if (!isPlatformsGenerated) {
            generatePlatforms()
            isPlatformsGenerated = true
        }

        Box(modifier = Modifier
            .fillMaxSize()
            .clickable {
                if (!isJumping) {
                    isJumping = true
                    launchJumpAnimation()
                }
            }) {
            Canvas(modifier = Modifier.fillMaxSize()) {
                val characterColor = Color.Green
                val platformColor = Color.Yellow

                val characterX = (characterPosition.value.x + tiltOffset).coerceIn(
                    0f,
                    screenWidthPx - characterSizePx
                )
                characterPosition.value = Offset(characterX, characterPosition.value.y)

                drawRect(
                    color = characterColor,
                    topLeft = characterPosition.value,
                    size = Size(characterSizePx, characterSizePx)
                )

                // Draw platforms
                for (platform in platforms) {
                    drawRect(
                        color = platformColor,
                        topLeft = platform.position,
                        size = Size(platform.width, platformSizePx / 5)
                    )
                }

                if (characterPosition.value.y <= 0f && !dialogVisible) {
                    dialogVisible = true
                }
            }

            if (dialogVisible) {
                AlertDialog(
                    onDismissRequest = {
                        dialogVisible = false
                        characterPosition.value = Offset(platforms[0].position.x, platforms[0].position.y - characterSizePx)
                    },
                    title = { Text(text = "Congratulations!") },
                    text = { Text(text = "You have reached the top!") },
                    confirmButton = {
                        Button(
                            onClick = {
                                dialogVisible = false
                                characterPosition.value = Offset(platforms[0].position.x, platforms[0].position.y - characterSizePx)
                            }
                        ) {
                            Text("Restart")
                        }
                    }
                )
            }
        }
    }

    data class Platform(val position: Offset, val width: Float)
    @Composable
    private fun generatePlatforms() {
        val numPlatforms = 10
        val platformGap = 2 * characterSizePx
        val initialY = screenHeightPx - platformGap

        for (i in 0 until numPlatforms) {
            val platformY = initialY - i * platformGap
            val platformWidth = (0.2f * screenWidthPx).coerceAtMost((platformSizePx * 2).coerceAtMost(screenWidthPx))
            val platformX = Random.nextFloat() * (screenWidthPx - platformWidth)
            val platform = Platform(Offset(platformX, platformY), platformWidth)
            platforms.add(platform)
        }

        characterPosition.value = Offset(platforms[0].position.x, platforms[0].position.y - characterSizePx)

        // Add a platform at the bottom
        val bottomPlatform = Platform(Offset(0f, screenHeightPx - platformSizePx / 5), screenWidthPx)
        platforms.add(bottomPlatform)
    }



    private fun launchJumpAnimation() {
        val originalY = characterPosition.value.y
        val jumpHeight = 500f
        val jumpSpeed = 20f
        val fallThreshold = screenHeightPx + characterSizePx

        lifecycleScope.launch {
            var yPos = originalY
            var collidedWithPlatform = false

            while (yPos > originalY - jumpHeight && isJumping) {
                yPos -= jumpSpeed
                characterPosition.value = Offset(characterPosition.value.x, yPos.coerceAtLeast(0f))
                if (checkPlatformCollision()) {
                    yPos = platforms.last { characterPosition.value.y < it.position.y }.position.y + platformSizePx / 5
                    collidedWithPlatform = true
                    break
                }
                delay(50)
            }

            while (isJumping || !checkPlatformCollision()) {
                yPos += jumpSpeed
                characterPosition.value = Offset(characterPosition.value.x, yPos.coerceAtMost(fallThreshold))
                if (checkPlatformCollision() || yPos >= fallThreshold) break
                delay(50)
            }

            isJumping = false
            if (characterPosition.value.y <= 0f) {
                dialogVisible = true
            }
        }
    }

    private fun checkPlatformCollision(): Boolean {
        val characterBottom = characterPosition.value.y + characterSizePx
        val characterTop = characterPosition.value.y

        if (characterBottom >= screenHeightPx) {
            // Character has fallen off the platforms, reset the game
            return false
        }

        for (platform in platforms) {
            val platformTop = platform.position.y
            val platformBottom = platform.position.y + platformSizePx / 5

            if (characterBottom <= platformBottom && characterBottom >= platformTop) {
                val characterLeft = characterPosition.value.x
                val characterRight = characterPosition.value.x + characterSizePx
                val platformLeft = platform.position.x
                val platformRight = platform.position.x + platform.width

                if (characterRight > platformLeft && characterLeft < platformRight) {
                    // Check if character is landing on the top of the platform
                    if(characterTop <= platformTop) {
                        return true // Character is still on a platform
                    }
                }
            }
        }

        return false // Character has not collided with any platform
    }
}
